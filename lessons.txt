1. Using a computational graph is nice. The user can build a computational graph first and then later repeatedly evaluate different nodes in it. We can trace the requirement dependencies and thus only evluate the nodes needed in the computation. In addition, because of topological sort we know the computations that are done before and thus makes the computatition logic easier.
2. For the gradients and the derivatives, the users predefine the gradient and the systems basically adds the corresponding to an artificially constructed graph that it can evaluate. It uses the same computional graph primivites thus and is very convenient. This logic becomes a little more complicated because a node can have multiple edges out of it that impact the target.
3. They seperate how the logic between the nodes which store the data and edges, from the operation which stores how to compute based on the node. Thus, they can actually have a singleton operator for the operation.
4. If you overwrite the add and the radd operator, you can allow users to use the plus and multiply operator. 
